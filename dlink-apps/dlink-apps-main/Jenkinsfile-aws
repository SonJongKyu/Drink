pipeline {
    agent any

    environment {
        DOCKER_COMPOSE_FILE = "docker-compose-build.yml"
        HARBOR_URL          = "192.168.3.81"
        SONAR_PROJECT_KEY   = "dlink-apps"
        ECR_URL = "084550838259.dkr.ecr.ap-northeast-2.amazonaws.com"
        AWS_REGION = "ap-northeast-2"
    }

    stages {

        stage('BuiLd Classes & SonarQube Analysis') {
            steps {
                script {

                    dir('spring-app') {
                        sh "./gradlew classes"
                    }

                    def scannerHome = tool 'sonarqube-scanner'
                    withSonarQubeEnv('sonarqube-server') {
                        sh """${scannerHome}/bin/sonar-scanner \\
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \\
                            -Dsonar.sources=. \\
                            -Dsonar.java.binaries=\$(find . -type d -name "build" | paste -sd ",") \\
                            -Dsonar.ts.tslint.reportPaths=reports/tslint.json \\
                            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
                            """
                    }
                }
            }
        }

        stage("Quality Gate") {
            steps {
                timeout(time: 1, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        stage('Detect & Build Changed Applications') {
            steps {
                script {
                    // (1) `git diff` ì‹¤í–‰í•˜ì—¬ ë³€ê²½ëœ `image:` ë¼ì¸ë§Œ ì¶”ì¶œ
                    def composeDiff = sh(
                        script: "git diff HEAD^ HEAD -- ${DOCKER_COMPOSE_FILE} | grep '^+.*image:' || true",
                        returnStdout: true
                    ).trim()

                    // (2) ë³€ê²½ëœ ë¼ì¸ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ
                    if (!composeDiff) {
                        echo "ğŸš€ No image changes detected in ${DOCKER_COMPOSE_FILE}. Skipping build."
                        currentBuild.result = 'SUCCESS'
                        return
                    }

                    echo "ğŸ“Œ ë³€ê²½ëœ ì´ë¯¸ì§€ ë¼ì¸:\n${composeDiff}"

                    def servicesToBuild = []
                    def versionMap = [:]
                    def pattern = ~/image:\s*(\S+)\/dlink\/([^:]+):([\w\.-]+)/  // ì •ê·œì‹ ê°œì„ 

                    // (3) `+` ê¸°ì¤€ìœ¼ë¡œ ì¤„ì„ ë¶„ë¦¬í•˜ì—¬ ì²˜ë¦¬
                    composeDiff.split('\n').each { line ->
                        line = line.trim() // ì•ë’¤ ê³µë°± ì œê±°
                        if (line.startsWith('+')) { // `+` í¬í•¨ëœ ì¤„ë§Œ ì²˜ë¦¬
                            def matcher = pattern.matcher(line)
                            if (matcher.find()) {
                                def harborUrl = matcher.group(1)   // IP ë˜ëŠ” ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì£¼ì†Œ
                                def serviceName = matcher.group(2) // ì„œë¹„ìŠ¤ëª…
                                def versionTag = matcher.group(3)  // ë²„ì „

                                echo "âœ… ë³€ê²½ ê°ì§€ë¨: ì„œë¹„ìŠ¤=${serviceName}, ë²„ì „=${versionTag}"

                                servicesToBuild.add(serviceName)
                                versionMap[serviceName] = versionTag
                            }
                        }
                    }

                    // (4) ì¤‘ë³µ ì œê±° ë° ìµœì¢… ë¹Œë“œí•  ì„œë¹„ìŠ¤ í™•ì¸
                    servicesToBuild = servicesToBuild.unique()
                    if (servicesToBuild.isEmpty()) {
                        echo "ğŸš€ No services need to be built. Skipping."
                        currentBuild.result = 'SUCCESS'
                        return
                    }

                    env.SERVICES_TO_BUILD = servicesToBuild.join(" ")
                    env.VERSION_MAP = versionMap.collect { k, v -> "${k}:${v}" }.join(",")

                    echo "ğŸ› ï¸ í˜„ì¬ ê°ì§€ëœ ì„œë¹„ìŠ¤ ë¦¬ìŠ¤íŠ¸: ${servicesToBuild}"
                    echo "ğŸ› ï¸ í˜„ì¬ ê°ì§€ëœ ë²„ì „ ë§µ: ${versionMap}"

                    // (5) Docker build ì‹¤í–‰
                    def buildCommand = "docker-compose -f ${DOCKER_COMPOSE_FILE} build ${servicesToBuild.join(' ')}"
                    echo "ğŸš€ ì‹¤í–‰í•  Docker Build ëª…ë ¹ì–´: ${buildCommand}"
                    sh buildCommand
                }
            }
        }

        stage('Push to AWS ECR') {
            when {
                expression { env.SERVICES_TO_BUILD && env.SERVICES_TO_BUILD.trim() != "" }
            }
            steps {
                script {
                    // AWS ECR ë ˆì§€ìŠ¤íŠ¸ë¦¬ URL

                    if (!env.VERSION_MAP) {
                        echo "âš ï¸ VERSION_MAPì´ ë¹„ì–´ ìˆìŒ. í‘¸ì‹œí•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤."
                        return
                    }

                    // AWS ECR ë¡œê·¸ì¸ ìˆ˜í–‰
                    echo "ğŸ” AWS ECR ë¡œê·¸ì¸ ì¤‘..."
                    def loginResult = sh(
                        script: "aws ecr get-login-password --region ${env.AWS_REGION} | docker login --username AWS --password-stdin ${env.ECR_URL}",
                        returnStatus: true
                    )

                    if (loginResult != 0) {
                        error("âŒ AWS ECR ë¡œê·¸ì¸ ì‹¤íŒ¨! Pushë¥¼ ì¤‘ë‹¨í•©ë‹ˆë‹¤.")
                    }

                    echo "âœ… AWS ECR ë¡œê·¸ì¸ ì„±ê³µ!"

                    // ë³€ê²½ëœ ì„œë¹„ìŠ¤ ë¦¬ìŠ¤íŠ¸ ë°˜ë³µ
                    env.SERVICES_TO_BUILD.split(" ").each { service ->
                        def imageEntry = env.VERSION_MAP.split(",").find { it.startsWith("${service}:") }
                        def imageTag = imageEntry ? imageEntry.split(":")[1] : "latest"
                        def ecrRepository = "${ECR_URL}/dlink/${service}"

                        echo "ğŸš€ í‘¸ì‹œí•  ì„œë¹„ìŠ¤: ${service}, íƒœê·¸: ${imageTag}"

                        // Docker ì´ë¯¸ì§€ê°€ ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                        def imageExists = sh(script: "docker images -q ${ecrRepository}:${imageTag}", returnStdout: true).trim()
                        if (!imageExists) {
                            echo "âŒ ì˜¤ë¥˜: ${ecrRepository}:${imageTag} ì´ë¯¸ì§€ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Pushë¥¼ ìŠ¤í‚µí•©ë‹ˆë‹¤."
                            return
                        }

                        // Docker ì´ë¯¸ì§€ í‘¸ì‹œ
                        sh """
                        docker push ${ecrRepository}:${imageTag}
                        """
                    }
                }
            }
        }

        stage('Update Manifests in dlink-manifests') {
            when {
                expression { env.SERVICES_TO_BUILD && env.SERVICES_TO_BUILD.trim() != "" }
            }
            steps {
                script {
                    echo "ğŸ” SERVICES_TO_BUILD: ${env.SERVICES_TO_BUILD}"
                    echo "ğŸ” VERSION_MAP: ${env.VERSION_MAP}"

                    // (1) ì„œë¹„ìŠ¤ëª… -> manifest patch íŒŒì¼ ë§¤í•‘
                    def patchMap = [
                        "api-gateway":      "gateway-patch.yaml",
                        "auth-service":     "auth-patch.yaml",
                        "alcohol-service":  "alcohol-patch.yaml",
                        "highball-service": "highball-patch.yaml",
                        "review-service":   "review-patch.yaml",
                        "pairing-service":  "pairing-patch.yaml",
                        "next-app":         "next-patch.yaml"
                    ]

                    // (2) Git clone & checkout
                    withCredentials([usernamePassword(credentialsId: 'github-access', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
                        sh """
                        rm -rf dlink-manifests
                        git clone https://\$GIT_USER:\$GIT_PASS@github.com/ACS7th/dlink-manifests.git
                        cd dlink-manifests
                        git checkout staging
                        git config user.name "dealim"
                        git config user.email "dealimmmm@gmail.com"
                        """

                        // (3) ë²„ì „ ë§µì„ `env.VERSION_MAP`ì—ì„œ ì¶”ì¶œ
                        def versionMap = [:]
                        env.VERSION_MAP.split(",").each { entry ->
                            def parts = entry.split(":")
                            if (parts.length == 2) {
                                versionMap[parts[0]] = parts[1]
                            }
                        }

                        // (4) ë¹Œë“œëœ ì´ë¯¸ì§€ ì •ë³´ ê¸°ë°˜ìœ¼ë¡œ manifest ì—…ë°ì´íŠ¸
                        env.SERVICES_TO_BUILD.split(" ").each { service ->
                            def patchFile = patchMap[service]
                            def currentVersion = versionMap[service]

                            if (patchFile && currentVersion) {
                                echo "ğŸ”„ ${patchFile} ì—…ë°ì´íŠ¸ ì¤‘ (ë²„ì „: ${currentVersion})"

                                sh """
                                sed -i 's|image: .*/dlink/${service}:.*|image: ${env.ECR_URL}/dlink/${service}:${currentVersion}|' dlink-manifests/overlays/cloud/patches/${patchFile}
                                """
                            } else {
                                echo "âš ï¸ ${service}ì— ëŒ€í•œ íŒ¨ì¹˜ íŒŒì¼ ë˜ëŠ” ë²„ì „ ì •ë³´ ì—†ìŒ"
                            }
                        }

                        // (5) Git commit & push
                        sh """
                        cd dlink-manifests
                        git add overlays/cloud/patches
                        git diff --cached --quiet || (git commit -m "Update image versions for CI" && git push origin staging)
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            echo 'âœ… Build succeeded!'
            slackSend(
                channel: '#dlk-cicd-events',
                color: 'good',
                message: "âœ… Jenkins Build ì„±ê³µ!\n - í”„ë¡œì íŠ¸: ${env.JOB_NAME}\n - ë¹Œë“œ ë²ˆí˜¸: #${env.BUILD_NUMBER}\n - í™•ì¸: ${env.BUILD_URL}"
            )
        }
        failure {
            echo 'âŒ Build failed!'
            slackSend(
                channel: '#dlk-cicd-events',
                color: 'danger',
                message: "âŒ Jenkins Build ì‹¤íŒ¨!\n - í”„ë¡œì íŠ¸: ${env.JOB_NAME}\n - ë¹Œë“œ ë²ˆí˜¸: #${env.BUILD_NUMBER}\n - í™•ì¸: ${env.BUILD_URL}"
            )
        }
        always {
            echo "ğŸ“Œ ë¹Œë“œ ì¢…ë£Œ (ì„±ê³µ/ì‹¤íŒ¨ ê´€ê³„ì—†ì´ ì‹¤í–‰ë¨)"
        }
    }
}
